{"./":{"url":"./","title":"介绍","keywords":"","body":"作者 余树，半个白羊半个处女，强迫症患者，爱折腾 ，喜骑行、旅行、摄影 关于本书 记录并用最简单明了的语言阐述基础知识点 深入理解 JS 核心和高级知识点 在多种场景下提高编程素养和代码质量 适宜人群 刚准备学习前端 具备 JavaScript 一定基础知识 开源协议 MIT By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"introduction/1-1.html":{"url":"introduction/1-1.html","title":"基础知识","keywords":"","body":"写一个 Hello Word const x = 'Hello Word' console.log(x) // Hello Word 关键字与保留字 在 JavaScript 语言中，内置有很多关键字和保留字，他们有很多用途，例如用 var 声明一个变量，用 while 写一 个循环语句，这里就不一一介绍了 注意事项：在使用严格模式下（use strict），若用关键字或保留字命名一个变量的话，会报错的，不能用于作为标识符或 属性名，当然这属于不规范的行为，我们应该杜绝 变量 JavaScript 是一门动态类型语言，自由松散，我们可以对一个变量定义任何数据类型，如若要对一个变量严格定义某种 数据类型，可以使用 TypeScript 后期我们会讲 变量简单来讲就是一个 值，每个变量都有一个名称，我们可以通过 变量名 访问使用变量的值 声明一个变量 使用关键字 var 声明一个变量，变量名为 x 并对变量名 x 用修饰符 = 赋值 // 声明变量的几种方式 //1 逗号分隔：先声明，后赋值 var x, y x = 1 y = 2 //2 声明并赋值 var x = 1 var y = 2 // 声明变量的几种情况 var x = 1 var x //1： x已经声明 =1 ，再次声明赋值 x，未做任何赋值操作，无效 x = 1 //1：不用关键字 var 声明也是可以，相当于 声明了一个 x 的全局变量，但不推荐这么做 var x = 1 var x = 2 //2：再次声明 x ，会覆盖前面的值 x // x is not defined ：x 变量名未赋值 JavaScript 引擎 浏览器的核心是两部分：渲染引擎和JavaScript解释器（又称 JavaScript 引擎） 不同的浏览器有不同的渲染引擎，Firefox 浏览器为 Gecko引擎，Safari 为 WebKit引擎，Chrome 为 Blink引 擎。它的主要作用是生成网页，通常分成四个阶段。 解析 HTML 为 DOM，解析 CSS 为 CSSOM（CSS Object Model） 将 DOM 和 CSSOM 合成一棵渲染树（render tree） 完成渲染树的布局（layout） 将渲染树绘制到屏幕 变量提升 变量提升顾名思义就是把一个变量的作用域范围给提升了 console.log(x) // undefined：拿到声明的变量名 x，再逐行运行， x 未赋值 var x = 1 console.log(y) //y is not defined：对全局声明变量无效 y = 1 console.log(z) //z is not defined：对 let 等关键字变量提升无效 let z = 1 JavaScript 解析过程：当 JavaScript 引擎解析代码的时候，首先获取所有声明的变量（不包含赋值)，最后才对代码逐行 运行，所以这就造成了一种现象。JavaScript 引擎在拿到所有变量后，最后再做执行的时候，所有的变量作用域范围都提 升到最前面。这就是变量提升变量提升只对关键字 var 有效，let const 等关键字和全局声明变量无效 命名规范 命名规范适用于团队之间的一些约定，更方便直观的维护组织代码 具体可以查考 Airbnb 的命名规范 By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"introduction/1-2.html":{"url":"introduction/1-2.html","title":"数据类型、类型转换","keywords":"","body":"基本类型 // 五种基本类型 var x = 1 // Number var x = '1' // String var x = true // Boolean var x= undefined // Undefined var x = null // Null // 复杂数据类型：Object var x = {age: 8 name: 'kevin'} // 键值对集合 => Object var x = [1, 2, 3] // 数组 => Object var x = () => {} // 函数 => Object // Symbol类型 var x = Symbol('kevin') 以上代码展示了 JS 五种基本数据类型，一种复杂数据类型Object，ES6 又新增了 Symbol 数据类型 数值（Number）：小数与整数 字符串（String）：字符串 布尔 （Bolean）：真假值（true || false） 未定义（Undefined）：该值未定义类型或不存在 无 （Null）：空对象指针，表示无 对象 （Object）： 是一种复杂数据类型，有分为三种 狭义的对象 obj 数组 [ ] 键值对集合 {} 函数 function Symbol ： 独一无二的 关于 undefined 使用 var 关键字声明了一个变量 x ，但未对 x 定义数据类型，这个变量初始化值为 undefined 未用 var 等关键字声明一个变量，例如：x ，系统会直接报错 （Uncaught ReferenceError: x is not defined） 关于 Null Null 代表一个空指针对象，例如你要对一个变量的值以后想保存为 Object 类型，推荐这个变量值初始化的时候赋值 Null ，因为可以用 typeof 来判断变量的类型，知道这个变量已经保存了一个对象引用 强制类型转换 Number() 将非数值转换为数值 Number()函数的转换规则如下 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0 如果是数字值，只是简单的传入和返回 如果是 null 值，返回 0 如果是 undefined，返回 NaN 如果是字符串，遵循下列规则 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即\"1\" 会变成 1，\"123\"会变成 123，而\"011\"会变成 11（注意：前导的零被忽略了） 如果字符串中包含有效的浮点格式，如\"1.1\"，则将其转换为对应的浮点数值（同样，也会忽 略前导零） 如果字符串中包含有效的十六进制格式， 例如 \"0xf\" ， 则将其转换为相同大小的十进制整 数值 如果字符串是空的（不包含任何字符），则将其转换为 0 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换 的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符 串值 '100' + 100 //'100100' Number('00100') //100 Number('+100') //100 Number('+100px') //NaN Number('') //0 Number(true) //1 Number(false) //0 Number([]) //0 Number(['']) //0 Number([12]) //12 Number([1, 2]) //NaN Number(['12']) //12 Number(null) //0 Number({ age: 18 }) //NaN，obj，Number方法转不了 Number({}) //NaN obj，Number方法转不了 Number(x) //undefined Number(() => {}) //NaN 函数， Number方法转不了 Number('0xA') // 10 (十六进制) Number(070) // 56 (八进制) parseInt() 与 parseFloat() parseInt() ：转换为整数；parseFloat()：转化为小数 parseInt() 比 Number() 更实用于转换整数，规则如下： Boolean 值，Null 值，undefined 值都返回 NAN 如果是数字值，只是简单的传入和返回 如果是字符串，遵循下列规则： 空字符返回 NaN 如果字符串中第一个包含数字（包括前面带正号或负号的情况），后面的字符会被忽略例如：'100px'，'-100px' 如果字符串以\"0x\"开头且后跟数字字符，就会将其当作一 个十六进制整数 如果是小数点字符串，会取整 parseInt('00100') //100 parseInt('+100') //100 parseInt('+100px') //100 parseInt('a100px') //NaN parseInt('') //NaN parseInt(true) //NaN parseInt(false) //NaN parseInt([]) //NaN parseInt(['']) //NaN parseInt([1]) //1 parseInt([1, 2]) //1 parseInt(['12']) //12 parseInt(null) //NaN parseInt({ age: 18 }) //NaN parseInt({}) //NaN parseInt(x) //undefined parseInt(() => {}) //NaN parseInt('0xA') // 10 (十六进制) parseInt(070) // 56 (八进制) 隐式类型转换 -*/% 减、乘、除、取余可以将字符串转成数字 +加号可以将数字转成字符串 ++ -- 加加、减减运算符可以把字符串转成数字 <> 大于号、小于号可以把字符串转成数字 == 比较运算符可以把字符串转换成数字 ! 取反 把右边的数据类型转成布尔值 2 * '1' //2 2 - '1' //1 1 + '1' //'11' let x = '1' ++x //2 '1' > 2 //false '1' == 2 //false !'0' //false isNaN NaN：即非数值（Not a Number）是一个特殊的数值 NaN 是个数字类型，但它不是个数字 一旦出现 NaN ，说明进行了非法的运算操作 NaN 是个 false，但不等于 false（Nan == false）// false NaN 与任何值都不相等，包括 NaN 本身 isNaN 执行过程： isNaN 可以用来判断该值是否可转换为数值类型或是否为非数字。isNaN 在接受到一个值时，会尝试调 用 Number() 将该数值转换为数值类型，可以转换的返回为 false，反之 true Number('kevin') //NaN 非法操作 NaN ? console.log(true) : console.log(false) // false NaN === NaN //false 不等于本身 isNaN(NaN) //false isNaN(10) //false（10 是一个数值） isNaN('10') //false（可以被转换成数值 10） isNaN('blue') //true（不能转换成数值） isNaN(true) //false（可以被转换成数值 1） By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"introduction/1-3.html":{"url":"introduction/1-3.html","title":"运算符","keywords":"","body":"运算符是用于操作表达式来计算或比较数据 算术运算符 + - * / % 赋值运算符 = += -= *= /= %= 比较运算符 > >= == === != !== 逻辑运算符 && （且） || （或） ! （否） ?: （三元条件） 运算符优先级 运算符 描述 . []() 字段访问、数组下标、函数调用以及表达式分组 ++ -- - ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建、未定义值 * / % 乘法、除法、取模 + - + 加法、减法、字符串连接 > >>> 移位 >= instanceof 小于、小于等于、大于、大于等于、instanceof == != === !== 等于、不等于、严格相等、非严格相等 & 按位与 ^ 按位异或 && 逻辑与 ?: 条件 = oP= 赋值、运算赋值 , 多重求值 By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"introduction/1-4.html":{"url":"introduction/1-4.html","title":"条件判断、循环","keywords":"","body":"条件判断 if 判断 if（条件）内可以是任意表达式；然后这个表达式求值的结果不一定是布尔值。 ECMAScript 会自动调用 Boolean() 转换函数将这个表达式的结果转换为一个布尔值 if (条件) alert('条件已满足') else alert('条件未满足') // 普通判断 const age = 24 if (age >= 18) { alert('成年人') } else { alert('未成年') } // 多行条件判断 if (age >= 18) { alert('成年人') } else if (age switch 判断 switch 与 if 一样，满足（条件）执行结果。switch 语句中的每一种情形（case）的含义是：“如果表达式等于这个值 （value），则执行后面的语句” 注意事项： break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字， 就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前 面任何一种情形的时候，执行代 码 const name = 'kevin' switch (name) { case 'kevin': alert('我是kevin') break // break注意要写，忽略的话，会自动执行下一个case语句 case 'tom': alert('我是tom') break default: // 相当于if语句中的else alert('我不是kevin也不是tom') } 三目运算 判断 三目运算符用作判断时，基本语法为: 条件 ? 语句 1 : 语句 2 当 条件 的值为真时执行语句1，否则执行语句2 一些简单的逻辑如果用 if 语句会显的罗里吧嗦，如果想更简单直观减少代码展示逻辑的话，可以用三元条件 const gender = '男' const isBoy = gender === '男' ? true : false 循环 for 语句 for 语句是在一个条件表达式为 true 的情况下，进行循环遍历，每次遍历，表达式中的 （i++） 都是递增，直到 条件不满足才会终止 for (let i = 0; i 以上代码的执行过程： let i = 0; 循环体内定义的变量 i 初始值是 0；i break 和 continue 语句 break 用于在 for 循环体内终止并跳出循环；continue 用于跳过循环中的一个迭代，并继续执行循环中的下一个迭代 //break终止循环 for (let i = 0; i //continue执行下一次迭代循环 for (let i = 0; i for-in 语句 for-in 遍历对象属性 const person = { age: 18, name: 'kevin', sex: '男' } //对一个对象属性做清空 for (const key in person) { // 判断对象是否有这个key值 if (person.hasOwnProperty(key)) { person[key] = '' } } console.log(person) // pserson: {age: '', name: '', sex: ''} while 语句 while （条件）满足时，会一直执行括号内的代码 let i = 0 while (i do-while 语句 do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会检测最后的条件。 换句话说，在对条件表达 式求值之前，循环体内的代码至少会被执行一次 let i = 0 do { console.log(i) i++ } while (i ES6 也出了很多循环语句，后期会整合一起讲 By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"grammar/2-1.html":{"url":"grammar/2-1.html","title":"函数","keywords":"","body":"函数是一个核心的概念。它可以封装任意多条语句，方便我们在任何地方任何时刻去调用。 声明一个函数 关键字 function 声明，函数包含一组参数和函数体；函数分具名函数与匿名函数 // 声明一个具名函数 function getUser() {} getUser() // 调用一个函数 // 匿名函数复制给一个变量（函数表达式） const getUser = function() {} getUser() // 调用，等同于上面代码 传参、arguments 函数可接收多个参数；函数体内内置了 arguments 对象，类似于一个数组，但不是 Array function getUser(name, age) { console.log(`我叫${name}，我今年${age}岁了`) // 我叫kevin，我今年18岁了 console.log(arguments[0]) // kevin console.log(arguments[1]) // 18 } getUser('kevin', 18) 函数返回值 return 默认函数返回值是 undefined 可返回任意数据类型 return 语句后面，代码不执行 // return 后面跟着一个匿名函数 function fn1() { return function() { alert(1) } } fn1() //function() {alert(1)} // fn1()后面再次执行了匿名函数()包括传参 function fn1() { return function(x) { alert(x) } } fn1()(100) //100 By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"grammar/2-2.html":{"url":"grammar/2-2.html","title":"作用域","keywords":"","body":"理解作用域 作用域是用于在可用范围、区域内进行读、写 引擎：从头到尾负责整个 JavaScript 程序的编译及执行过程 根据 var function 等关键字找变量，在代码允许之前， 所有变量都是 undefined，所有函数都是函数块 ；遇 到重名的，只留下一个 逐行解读代码，都回去预解析库里查询下。解读遇到表达式可以改变解析库的值 编译器：负责语法分析及代码生成等脏活累活 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的 代码对这些标识符的访问权 案例讲解 alert(x) // undefined const x = 1 alert(x) // function x(){alert(4)} var x = 1 alert(x) // 1 function x() { alert(2) } alert(x) // 1 var x = 3 alert(x) // 3 function x() { alert(4) } alert(x) // 3 x() // x is not a function; //1.预解析先寻找var function 关键字 // var x= 1 等于 x = undefined // function x(){alert(2)} 等于 x = function x(){alert(2)} // var x=3 这时候 x 是函数块，和 x 重名了。变量和函数重名，只保留函数 // 按照这样的推理，最后预解析等到的x = function x(){alert(4)} //2.然后进行逐行解读代码，这时候解析库内存着x = function x(){alert(4)} //alert(x) 等于 function x(){alert(4)} //var x=1 解读这行，当前x是个函数块，读到当前是个表达式，该表解析库x的值 = 1 //alert(x) 等于 1 //function x(){alert(2)} 解读这行这只是一个函数声明，并不是表达式，改变不了解析库值 //alert(x) 还是等于 1 //var x=3 解读这行，这是表达式改变解析库 x值 = 3 //继续按照这样的逻辑推理... //x() 解读这行的时候，当前解析库中x 值为3，所以报错 var x = 1 function fn1() { function fn3() { var x = 4 fn2() } var x = 2 return fn3 } function fn2() { console.log(x) } var fn = fn1() fn() //x // 开始预解析 // x = undefined , fn1 = function fn1(){}, fn2 = function fn2(){}, fn = undefined // 开始解读 // x = 1 // 函数声明不做操作 // fn = fn1() 函数调用直接到fn3函数体内，局部x=4；跳到fn2函数，fn2找不到x，向外面跳，找到全局x=1 // 最终得到 1 var x = 1 function fn1() { function fn2() { console.log(x) } function fn3() { var x = 4 fn2() } var x = 2 return fn3 } var fn = fn1() fn() // 2 原理如上 var x = 1 function fn1() { function fn3() { function fn2() { console.log(x) } var x fn2() x = 4 } var x = 2 return fn3 } var fn = fn1() fn() // undefined // 当执行fn2()的时候，因为js代码是从上往下的，所以当前x=undefined // 执行完fn2() 后，fn2()函数体内的x是4 By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"grammar/2-3.html":{"url":"grammar/2-3.html","title":"闭包","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"stdlib/3-1.html":{"url":"stdlib/3-1.html","title":"Date","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"stdlib/3-2.html":{"url":"stdlib/3-2.html","title":"Math","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"stdlib/3-3.html":{"url":"stdlib/3-3.html","title":"RegExp","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"stdlib/3-4.html":{"url":"stdlib/3-4.html","title":"setTimeout","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"oop/4-1.html":{"url":"oop/4-1.html","title":"理解对象","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"oop/4-2.html":{"url":"oop/4-2.html","title":"创建对象","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"oop/4-3.html":{"url":"oop/4-3.html","title":"this","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"oop/4-4.html":{"url":"oop/4-4.html","title":"原型、原型链","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"oop/4-5.html":{"url":"oop/4-5.html","title":"继承","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"browser/5-1.html":{"url":"browser/5-1.html","title":"Http","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"browser/5-2.html":{"url":"browser/5-2.html","title":"DOM","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"browser/5-3.html":{"url":"browser/5-3.html","title":"BOM","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"browser/5-4.html":{"url":"browser/5-4.html","title":"存储","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"browser/5-5.html":{"url":"browser/5-5.html","title":"跨域","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "},"browser/5-6.html":{"url":"browser/5-6.html","title":"Ajax","keywords":"","body":" By 余树，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-02-07 14:08:05 "}}